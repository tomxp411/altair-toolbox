	SUBTTL	Common file for BASIC interpreter
	.SALL	

CONTO	SET	15			;CHARACTER TO SUPRESS OUTPUT (USUALLY CONTROL-O)
DBLTRN	SET	0			;FOR DOUBLE PRECISION TRANSCENDENTALS
	IF2	

	.PRINTX	/EXTENDED/


	.PRINTX	/LPT/

	.PRINTX	/CPM DISK/


	.PRINTX	/Z80/

	.PRINTX	/FAST/

	.PRINTX	/5.0 FEATURES/

	.PRINTX	/ANSI COMPATIBLE/
	ENDIF

CLMWID	SET	14			;MAKE COMMA COLUMNS FOURTEEN CHARACTERS
DATPSC	SET	128			;NUMBER OF DATA BYTES IN DISK SECTOR
LINLN	SET	80			;TERMINAL LINE LENGTH 
LPTLEN	SET	132
BUFLEN	SET	255			;LONG LINES
NAMLEN	SET	40			;MAXIMUM LENGTH NAME -- 3 TO 127

NUMLEV	SET	0*20+19+2*5		;NUMBER OF STACK LEVELS RESERVED
					;BY AN EXPLICIT CALL TO GETSTK

STRSIZ	SET	4

STRSIZ	SET	3
NUMTMP	SET	3			;NUMBER OF STRING TEMPORARIES

NUMTMP	SET	10

MD.RND	SET	3			;THE MODE NUMBER FOR RANDOM FILES
MD.SQI	SET	1			;THE MODE NUMBER FOR SEQUENTIAL INPUT FILES
					;NEVER WRITTEN INTO A FILE
MD.SQO	SET	2			;THE MODE FOR SEQUENTIAL OUTPUT FILES
					;AND PROGRAM FILES
CPMWRM	SET	0			;CP/M WARM BOOT ADDR
CPMENT	SET	CPMWRM+5		;CP/M BDOS CALL ADDR
	CSEG	
TRUROM	SET	0
	PAGE
	TITLE	INIT INITAILIZATION FOR BASIC 8080/Z80 GATES/ALLEN/DAVIDOFF
SWTCHR	SET	57O			;DEFAULT SWITCH CHARACTER IS SLASH
	EXTRN	CNSGET
	EXTRN	CHRGTR
	EXTRN	OUTDO,LINPRT,MEMSIZ,CRDO,TXTTAB,OMERR
	EXTRN	REASON
	EXTRN	READY,STKINI,CURLIN,REPINI
	EXTRN	DCOMPR
	EXTRN	SYNCHR
	EXTRN	ERRFLG

	EXTRN	MAXFIL
	EXTRN	LPTPOS
	EXTRN	QINLIN,BUF,SNERR,FCERR,ATN,ATNFIX,COSFIX,TANFIX,SINFIX,COS
	PAGE
	SUBTTL	SYSTEM INITIALIZATION CODE
;THIS IS THE SYSTEM INITIALIZATION CODE
;IT SHOULD BE LOADED AT THE END OF THE BASIC
;INTERPRETER

	EXTRN	STROUT
	PUBLIC	TSTACK
	PUBLIC	INITSA,INIT
INITSA:
	EXTRN	NODSKS
	CALL	NODSKS
	LHLD	TXTTAB
	DCX	H
	MVI	M,0
	EXTRN	LRUN
	LHLD	CPMFIL			;POINT TO START OF COMMAND LINE
	MOV	A,M			;GET BYTE POINTED TO
	ORA	A			;IF ZERO, NO FILE SEEN
	JNZ	LRUN			;TRY TO RUN FILE
	JMP	READY
ENDIO:	DS	2
INIT:
	LXI	H,TSTACK		;SET UP TEMP STACK
	SPHL	
	XRA	A			;INITIALIZE PROTECT FLAG
	EXTRN	PROFLG
	STA	PROFLG
	EXTRN	TOPMEM,FRETOP
	SHLD	TOPMEM
	EXTRN	SAVSTK
	SHLD	SAVSTK			;WE RESTORE STACK WHEN ERRORS
	LHLD	CPMWRM+1		;GET START OF BIOS VECTOR TABLE
	LXI	B,0+4			;CSTS
	DAD	B			;ADD FOUR
	MOV	E,M			;PICK UP CSTS ADDRESS
	INX	H
	MOV	D,M
	XCHG				;GET CSTS ADDRESS
	SHLD	CONST3##+1		;THIRD CONTROL-C CHECK
	SHLD	CONSTS##+1		;SAVE
	SHLD	CONST2##+1		;FAST CONTROL-C CHECK
	XCHG				;POINTER BACK TO [H,L]
	INX	H			;POINT AT CI ADDRESS
	INX	H
	MOV	E,M			;GET LOW BYTE OF CI ADDRESS
	INX	H
	MOV	D,M			;GET HIGH BYTE
	XCHG				;INPUT ADDRESS TO [H,L]
	SHLD	CONIN##+1		;SAVE IN CONSOLE INPUT CALL
	XCHG				;POINTER BACK TO [H,L]
	INX	H			;SKIP "JMP" OPCODE
	INX	H			;BUMP POINTER
	MOV	E,M			;GET OUTPUT ROUTINE ADDRESS
	INX	H
	MOV	D,M
	XCHG				;INTO [H,L]
	SHLD	CONOUT##+1		;SAVE INTO OUTPUT ROUTINE
	XCHG				;POINTER BACK TO [H,L]
	INX	H			;NOW POINT TO PRINTER OUTPUT
	INX	H			;ROUTINE ADDRESS
	MOV	E,M			;PICK IT UP
	INX	H
	MOV	D,M
	XCHG				;GET ADDRESS INTO [D,E]
	SHLD	LPTOUT##+1		;SET PRINT ROUTINE ADDRESS

;	Check CP/M Version Number

	EXTRN	CPMVRN,CPMREA,CPMWRI

	MVI	C,12			;Version Test
	CALL	CPMENT
	STA	CPMVRN			;[A] = Version Number (0 = 1.x)
	ORA	A			;Test version number
	LXI	H,21*256+20+0		;1.x Read / Write
	JZ	CPMVR1
	LXI	H,34*256+33+0		;2.x Read / Write
CPMVR1:	SHLD	CPMREA			;Save Read/Write Codes
	LXI	H,0+65534		;SAY INITIALIZATION IS EXECUTING
	SHLD	CURLIN			;IN CASE OF ERROR MESSAGE
	EXTRN	CNTOFL
	XRA	A
	STA	CNTOFL
	EXTRN	ENDBUF
	STA	ENDBUF			;MAKE SURE OVERRUNS STOP
	EXTRN	CHNFLG,MRGFLG
	STA	CHNFLG			;MAKE SURE CHAINS AND MERGES
	STA	MRGFLG			;DONT TRY TO HAPPEN
	STA	ERRFLG			;DON'T ALLOW EDIT TO BE CALLED ON ERRORS
	LXI	H,0			;GET 0
	SHLD	LPTPOS##		;ZERO FLAG AND POSITION
	EXTRN	MAXREC
	LXI	H,0+128			;DEFAULT MAX REC SIZE
	SHLD	MAXREC
	EXTRN	TEMPST,TEMPPT
	LXI	H,TEMPST
	SHLD	TEMPPT
	EXTRN	PRMSTK,PRMPRV
	LXI	H,PRMSTK		;INITIALIZE PARAMETER BLOCK CHAIN
	SHLD	PRMPRV
	LHLD	CPMENT+1		;GET LAST LOC IN MEMORY
	SHLD	MEMSIZ			;USE AS DEFAULT
;
;
; THE FOLLOWING CODE SCANS A CP/M COMMAND LINE FOR BASIC.
; THE FORMAT OF THE COMMAND IS:
;
; BASIC <FILE NAME>[/M:<TOPMEM>][/F:<FILES>]
;
;*
	MVI	A,3			;DEFAULT FILES
	STA	MAXFIL			;BY SETTING MAXFIL=3
	LXI	H,ZEROB			;POINT AT ZERO BYTE
	SHLD	CPMFIL			;SO IF RE-INITAILIZE OK
	LDA	COMAGN			;HAVE WE ALREADY READ COMMAND LINE
	ORA	A			;AND GOT ERROR?
	JNZ	ERRCMD			;THEN DEFAULT
	INR	A			;MAKE NON-ZERO
	STA	COMAGN			;STORE BACK NON-ZERO FOR NEXT TIME
TBUFF	SET	CPMWRM+128		;WHERE CP/M COMMAND BUFFER IS LOCATED

	LXI	H,TBUFF			;POINT TO FIRST CHAR OF COMMAND BUFFER
	MOV	A,M			;WHICH CONTAINS # OF CHARS IN COMMAND
	ORA	A			;IS THERE A COMMAND?
	SHLD	CPMFIL			;SAVE POINTER TO THIS ZERO
	JZ	DONCMD			;NOTHING IN COMMAND BUFFER
	MOV	B,M			;AND [B]
	INX	H			;POINT TO FIRST CHAR IN BUFFER
TBFLP:	MOV	A,M			;GET CHAR FROM BUFFER
	DCX	H			;BACK UP POINTER
	MOV	M,A			;STORE CHAR BACK
	INX	H			;NOW ADVANCE CHAR TO ONE PLACE
	INX	H			;AFTER PREVIOUS POSIT.
	DCR	B			;DECREMENT COUNT OF CHARS TO MOVE
	JNZ	TBFLP			;KEEP MOVING CHARS
	DCX	H			;BACK UP POINTER
ENDCMD:	MVI	M,0			;STORE TERMINATOR FOR CHRGET (0)
	SHLD	CPMFIL			;SAVE POINTER TO NEW ZERO (OLD DESTROYED)
	LXI	H,TBUFF-1		;POINT TO CHAR BEFORE BUFFER
	CALL	CHRGTR			;IGNORE LEADING SPACES
	ORA	A
	JZ	DONCMD			;END OF COMMAND
	CPI	SWTCHR			;IS IT A SLASH
	JZ	FNDSLH			;YES
	DCX	H			;BACK UP POINTER
	MVI	M,34			;STORE DOUBLE QUOTE
	SHLD	CPMFIL			;SAVE POINTER TO START OF FILE NAME
	INX	H			;BUMP POINTER
ISSLH:	CPI	SWTCHR			;OPTION?
	JZ	FNDSLH			;YES
	CALL	CHRGTR			;SKIP OVER CHAR IN FILE NAME
	ORA	A			;SET CC'S
	JNZ	ISSLH			;KEEP LOOKING FOR OPTION
	JMP	DONCMD			;THATS EIT
FNDSLH:	MVI	M,0			;STORE TERMINATOR OVER "/"
SCANSW:	CALL	CHRGTR			;GET CHAR AFTER SLASH
SCANS1:
	CPI	'S'			;IS IT /S: ? (SET MAX RECORD SIZE)
	JZ	WASS			;YES
	CPI	'M'			;MEMORY OPTION
	PUSH	PSW			;SAVE INDICATOR
	JZ	WASM			;WAS MEMORY OPTION
	CPI	'F'			;FILES OPTION
	JNZ	SNERR##			;NOT "M" OR "F" ERROR
WASM:	CALL	CHRGTR			;GET NEXT CHAR
	CALL	SYNCHR
	DB	':'			;COLON SHOULD FOLLOW
	CALL	CNSGET			;GET VALUE FOLLOWING COLON
	POP	PSW			;GET BACK M/F FLAG
	JZ	MEM			;WAS MEMORY OPTION
	MOV	A,D			;FILES CANT BE .GT. 255
	ORA	A			;SET CC'S
	JNZ	FCERR##			;FUNCTION CALL ERROR
	MOV	A,E			;GET LOW BYTE
	CPI	16			;MUST BE .LT. 16
	JNC	FCERR##
	STA	MAXFIL			;STORE IN # OF FILES
	JMP	FOK			;DONE
MEM:	XCHG				;PUT VALUE IN [D,E]
	SHLD	MEMSIZ			;SAVE INTO MEMSIZE
	XCHG				;GET BACK TEXT POINTER
FOK:	DCX	H			;RESCAN LAST CHAR
	CALL	CHRGTR			;BY CALLING CHRGET
	JZ	DONCMD			;END OF COMMAND
	CALL	SYNCHR
	DB	SWTCHR			;SLASH SHOULD FOLLOW
	JMP	SCANS1			;SCAN NEXT SWITCH
WASS:	CALL	CHRGTR			;GET CHAR AFTER "S"
	CALL	SYNCHR
	DB	':'			;MAKE SURE COLON FOLLOWS
	CALL	CNSGET			;GET VALUE FOLLOWING COLON
	XCHG				;SAVE IT
	SHLD	MAXREC
	XCHG	
	JMP	FOK			;CONTINUE SCANNING
ZEROB:	DB	0			;ZERO BYTE
CPMFIL:	DS	2			;POINTER TO BASIC LOAD FILE
COMAGN:	DB	0			;WE HAVENT SCANNED COMMAND YET
ERRCMD:
DONCMD:
ASKMEM:
USEDEF:	DCX	H
	LHLD	MEMSIZ			;GET SIZE OF MEMORY
	PUSH	H			;ALSO SAVE FOR LATER
					;SET UP DEFAULT STRING SPACE
	POP	H
	DCX	H			;ALWAYS LEAVE TOP BYTE UNUSED BECAUSE
					;VAL(STRING) MAKES BYTE IN MEMORY
					;BEYOND LAST CHAR OF STRING=0
	SHLD	MEMSIZ			;SAVE IN REAL MEMORY SIZE
	DCX	H			;ONE LOWER IS STKTOP
	PUSH	H			;SAVE IT ON STACK



					;KEEP ALL FUNCTIONS

;
; DISK INITIALIZATION ROUTINE
; SETUP  FILE INFO BLOCKS
; THE NUMBER OF EACH AND INFORMATION FOR
; GETTING TO POINTERS TO EACH IS STORED. NO LOCATIONS ARE
; INITIALIZED, THIS IS DONE BY NODSKS, FIRST CLOSING ALL FILES.
; THE NUMBER OF FILES IS THE FILE POINTER TABLE
;
	PUBLIC	DSKDAT
DSKDAT	SET	ENDIO			;START DATA AFTER ALL CODE
ASKSK:
	LDA	MAXFIL			;GET HIGHEST FILE #
	LXI	H,DSKDAT		;GET START OF MEMORY
	EXTRN	FILPT1,FILPTR,MAXFIL,DBLK.C
	SHLD	FILPT1
	LXI	D,FILPTR		;POINT TO TABLE TO SET UP
	STA	MAXFIL			;REMEMBER HOW MANY FILES
	INR	A			;ALWAYS FILE 0 FOR INTERNAL USE
	LXI	B,DBLK.C		;SIZE OF A FILE INFO BLOCK PLUS $CODE
LOPFLB:	XCHG				;[H,L] POINT INTO POINTER BLOCK
	MOV	M,E			;STORE THE POINTER AT THIS FILE
	INX	H
	MOV	M,D
	INX	H
	XCHG	
	DAD	B			;[H,L] POINT TO NEXT INFO BLOCK
	EXTRN	FNZBLK
	PUSH	H			;SAVE [H,L]
	LHLD	MAXREC			;GET MAX RECORD SIZE
	LXI	B,FNZBLK		;GET SIZE OF OTHER STUFF
	DAD	B
	MOV	B,H
	MOV	C,L			;RESULT TO [B,C]
	POP	H			;RESTORE [H,L]
	DCR	A			;ARE THERE MORE?
	JNZ	LOPFLB
HAVFNS:					;TEXT ALWAYS PRECEDED BY ZERO
					;STORE IT
	INX	H			;INCREMENT POINTER
	SHLD	TXTTAB			;SAVE BOTTOM OF MEMORY
	SHLD	SAVSTK			;WE RESTORE STACK WHEN ERRORS
	POP	D			;GET  CURRENT MEMSIZ
	MOV	A,E			;CALC TOTAL FREE/8
	SUB	L
	MOV	L,A
	MOV	A,D
	SBB	H
	MOV	H,A
	JC	OMERR
	MVI	B,3			;DIVIDE BY 2 THREE TIMES
SHFLF3:	ORA	A
	MOV	A,H
	RAR	
	MOV	H,A
	MOV	A,L
	RAR	
	MOV	L,A
	DCR	B
	JNZ	SHFLF3
	MOV	A,H			;SEE HOW MUCH
	CPI	2			;IF LESS THAN 512 USE 1 EIGHTH
	JC	SMLSTK
	LXI	H,0+512
SMLSTK:	MOV	A,E			;SUBTRACT STACK SIZE FROM TOP MEM
	SUB	L
	MOV	L,A
	MOV	A,D
	SBB	H
	MOV	H,A
	JC	OMERR
	SHLD	MEMSIZ
	XCHG	
	SHLD	TOPMEM
	SHLD	FRETOP			;REASON USES THIS...
	SPHL				;SET UP NEW STACK
	SHLD	SAVSTK
	LHLD	TXTTAB
	XCHG	
	CALL	REASON
	MOV	A,L			;SUBTRACT MEMSIZ-TXTTAB
	SUB	E
	MOV	L,A
	MOV	A,H
	SBB	D
	MOV	H,A
	DCX	H			;SINCE TWO ZEROS EXIST BETWEEN
	DCX	H			;TXTTAB AND STREND, ADJUST
	PUSH	H			;SAVE NUMBER OF BYTES TO PRINT
	LXI	H,HEDING		;GET HEADING ("BASIC VERSION...")
	CALL	STROUT			;PRINT IT
	POP	H			;RESTORE NUMBER OF BYTES TO PRINT
	CALL	LINPRT			;PRINT # OF BYTES FREE
	LXI	H,WORDS			;TYPE THE HEADING
	CALL	STROUT			;"BYTES FREE"
	LXI	H,STROUT
	SHLD	REPINI+1
	CALL	CRDO			;PRINT CARRIAGE RETURN
	EXTRN	READYR
	LXI	H,READYR
	EXTRN	JMPINI
	SHLD	JMPINI+1
	JMP	INITSA


AUTTXT:	DB	13
	DB	10
	DB	10
	DC	'Owned by Microsoft'
	DB	13
	DB	10
	DB	0


WORDS:	DC	' Bytes Free'
	DB	0
HEDING:
	DB	26
	DC	'BASIC 5.2'
	DB	13
	DB	10



	DC	'MAGIC Operating System'
	DB	13
	DB	10
	DC	'    Copyright 1982 (C)'
	DB	13,10
	DB	32,32,32,32,32
	DB	0
LASTWR::				;LAST WORD OF SYSTEM CODE+1
	DS	70+300*0+200*0+30*0	;SPACE FOR TEMP STACK
TSTACK:
					;MAKE SURE LAST WORD PUNCHED IS OK
	END	
